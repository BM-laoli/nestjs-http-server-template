# 与其它的技术进行集成
>
> 与其它的技术进行集成 , 比如数据库、配置、验证、高数缓存、序列化、Job、log、cookie、事件、文件上传.....

## 数据库集成( Mysql + Mongo )
>
> 由于前面的 一期 已经简约的说明了 这里就不再另写了，我们只补充没有说明的地方

### Mysql
>
> mysql 相关的内容 我再以前一期的文章有详细的说明，请移步到这里 <a>一期文章</a>

### MongoDB
>
> 从零开始 集成

一些基础的mongodb 技术，我之前的文章也有详细的提到，请参见 <a href="https://juejin.cn/post/7104641797514592293">Nodejs + MongoDB </a>

1. 使用 docker 部署 mongodb <a href="https://hub.docker.com/_/mongo/">Mongo</a>

```shell
$ docker pull mongo
$  docker run -itd --name mongo -p 27017:27017 mongo --auth
$ docker exec -it mongo
# 进入这个 容器 里面
$  mongosh 
# 注意是mongosh 不再是mongo  https://www.mongodb.com/docs/manual/release-notes/6.0-compatibility/#legacy-mongo-shell-removed

# 创建一个名为 admin，密码为 123456 的用户。
>  db.createUser({ user:'admin',pwd:'123456',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},"readWriteAnyDatabase"]});
# 尝试使用上面创建的用户信息进行连接。
> db.auth('admin', '123456')

```

2. 开始集成

先来安装必要的依赖

```shell
yarn add  @nestjs/mongoose mongoose
```

建立连接

```ts
// 我自己新建了一个 core module 核心的功能逻辑都可以丢这里来
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
@Module({
  imports: [
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
    }),
  ],
  controllers: [], 
  providers: [],
})
export class CoreModule {}

```

创建模型

```ts
// 建议文件夹放到 module 相关性的文件夹下
import { Prop, Schema, SchemaFactory, raw } from '@nestjs/mongoose';
import { Document } from 'mongoose';

// 声明 document 类型
export type CatDocument = Cat & Document;

// 定义 这个schema class
// @Schema()  当然你可以使用 DefinitionsFactory 来生产一个更原始的 schema

// @Schema 会把 cat 映射到 同名的 cat 复数 Collection 中去
// 注意这个 @Schema  可以接受更多的参数 （https://mongoosejs.com/docs/guide.html#options）
@Schema({
  autoIndex: true,
})
export class Cat extends Document {
  // @Props 非常强大 不仅可以 定义类型 也可以定义验证规则，详细稳定  https://mongoosejs.com/docs/schematypes.html
  @Prop()
  name: string;

  @Prop()
  age: number;

  @Prop()
  breed: string;

  @Prop([String])
  tags: string[];

  @Prop({ required: true })
  sex: string;

  @Prop(
    raw({
      firstName: { type: String },
      lastName: { type: String },
    }),
  )
  details: Record<string, any>;
}

export const CatSchema = SchemaFactory.createForClass(Cat);

// 如果不习惯使用装饰器 可以 直接 monogose
// import * as mongoose from 'mongoose';
// export const CatSchema = new mongoose.Schema({
//   name: String,
//   age: Number,
//   breed: String,
// });

```

使用

```ts
// module
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

import { CatController } from './cat.controller';
import { CatService } from './cat.service';
import { Cat, CatSchema } from './schemas/cat.schema';

@Module({
  imports: [
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
    ),
  ],
  controllers: [CatController],
  providers: [CatService],
})
export class CatModule {}


// service
import { Injectable } from '@nestjs/common';
import { InjectConnection, InjectModel } from '@nestjs/mongoose';
import { Connection, Model } from 'mongoose';
import { Cat, CatDocument } from './schemas/cat.schema';

@Injectable()
export class CatService {
  // 注入model / 连接池（后者的功能要更强大 (https://mongoosejs.com/docs/api/connection.html#Connection())
  constructor(
    @InjectModel('Cat') private catModel: Model<CatDocument>,
    @InjectConnection() private connection: Connection,
  ) {}

  getHello(): string {
    return 'Hello World!';
  }

  async create(data: any): Promise<Cat> {
    const createCat = new this.catModel(data);
    return createCat.save();
  }
}

@Controller('cat')
export class CatController {
  constructor(private readonly catService: CatService) {}

  @Post('create')
  create(@Body() body: any) {
    return this.catService.create(body);
  }
}

```

其他的高级操作

```ts
// 如果需要 多数据库连接请使用
// core
  imports: [
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
      connectionName: 'testDB',
    }),
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB2', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
      connectionName: 'testDB2',
    }),
  ],

// module
imports: [
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
      'testDB',
    ),
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
      'testDB2',
    ),
  ],

  // service
  @Injectable()
export class CatService {
  constructor(
    @InjectModel('Cat', 'testDB2') private catModel: Model<CatDocument>,
  ) {}

  getHello(): string {
    return 'Hello World!';
  }

  async create(data: any): Promise<Cat> {
    const createCat = new this.catModel(data);
    return createCat.save();
  }
}

```

mongoDB 中间件 和 plugin 的使用

```ts
// 间件是针对Schema层级的 （https://mongoosejs.com/docs/middleware.html）

 MongooseModule.forFeatureAsync([
      {
        name: 'Cat',
        useFactory: () => {
          const schema = CatsSchema;
          // 了解 mongoose 的朋友都知道 这个基本上就上mongoose 的基操
          schema.pre('save', () => console.log('Hello from pre save'));
          return schema;
        },
      },
    ]),

// 类似的 plugin 也是如此 https://mongoosejs.com/docs/plugins.html

// core 
// 要向所有 schema 中立即注册一个插件，调用Connection对象中的.plugin()方法。你可以在所有模型创建前访问连接。使用connectionFactory来实现：
MongooseModule.forRoot('mongodb://localhost/test', {
      connectionFactory: (connection) => {
        connection.plugin(require('mongoose-autopopulate'));
        return connection;
      },
    }),

// module
// 仅对 某个scheme
   MongooseModule.forFeatureAsync([
      {
        name: 'Cat',
        useFactory: () => {
          const schema = CatsSchema;
          schema.plugin(require('mongoose-autopopulate'));
          return schema;
        },
      },
    ]),
  ],
```

对于测试（单元测试什么的
**一般而言我们通常希望避免任何数据库连接**

解决方案是创建模拟model

```ts
@Module({
  providers: [
    CatsService,
    {
      provide: getModelToken('Cat'), // getModelToken @nestjs/mongoose 它返回一个 硬编码 实例对象
      useValue: catModel,
    },
  ],
})
export class CatsModule {}

```

对于数据的关联操作，请直接参考 <a href="https://juejin.cn/post/7104641797514592293">这里</a> 稳定

## 配置
>
> 一期有详细的描述 不做过多赘述

## 验证
>
> 我们讲一下细节问题

## 序列化问题

## API多版本

## Job

## 队列问题

## 事件

## 压缩

## 文件上传

## 流处理文件

## Http模块

## Session绘画

## MVC

## 性能(Fastify)

## Service端的事件发送

# 与其它的技术进行集成
>
> 与其它的技术进行集成 , 比如数据库、配置、验证、高数缓存、序列化、Job、log、cookie、事件、文件上传.....

## 数据库集成( Mysql + Mongo )
>
> 由于前面的 一期 已经简约的说明了 这里就不再另写了，我们只补充没有说明的地方

### Mysql
>
> mysql 相关的内容 我再以前一期的文章有详细的说明，请移步到这里 <a>一期文章</a>

### MongoDB
>
> 从零开始 集成

一些基础的mongodb 技术，我之前的文章也有详细的提到，请参见 <a href="https://juejin.cn/post/7104641797514592293">Nodejs + MongoDB </a>

1. 使用 docker 部署 mongodb <a href="https://hub.docker.com/_/mongo/">Mongo</a>

```shell
$ docker pull mongo
$  docker run -itd --name mongo -p 27017:27017 mongo --auth
$ docker exec -it mongo
# 进入这个 容器 里面
$  mongosh 
# 注意是mongosh 不再是mongo  https://www.mongodb.com/docs/manual/release-notes/6.0-compatibility/#legacy-mongo-shell-removed

# 创建一个名为 admin，密码为 123456 的用户。
>  db.createUser({ user:'admin',pwd:'123456',roles:[ { role:'userAdminAnyDatabase', db: 'admin'},"readWriteAnyDatabase"]});
# 尝试使用上面创建的用户信息进行连接。
> db.auth('admin', '123456')

```

2. 开始集成

先来安装必要的依赖

```shell
yarn add  @nestjs/mongoose mongoose
```

建立连接

```ts
// 我自己新建了一个 core module 核心的功能逻辑都可以丢这里来
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
@Module({
  imports: [
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
    }),
  ],
  controllers: [], 
  providers: [],
})
export class CoreModule {}

```

创建模型

```ts
// 建议文件夹放到 module 相关性的文件夹下
import { Prop, Schema, SchemaFactory, raw } from '@nestjs/mongoose';
import { Document } from 'mongoose';

// 声明 document 类型
export type CatDocument = Cat & Document;

// 定义 这个schema class
// @Schema()  当然你可以使用 DefinitionsFactory 来生产一个更原始的 schema

// @Schema 会把 cat 映射到 同名的 cat 复数 Collection 中去
// 注意这个 @Schema  可以接受更多的参数 （https://mongoosejs.com/docs/guide.html#options）
@Schema({
  autoIndex: true,
})
export class Cat extends Document {
  // @Props 非常强大 不仅可以 定义类型 也可以定义验证规则，详细稳定  https://mongoosejs.com/docs/schematypes.html
  @Prop()
  name: string;

  @Prop()
  age: number;

  @Prop()
  breed: string;

  @Prop([String])
  tags: string[];

  @Prop({ required: true })
  sex: string;

  @Prop(
    raw({
      firstName: { type: String },
      lastName: { type: String },
    }),
  )
  details: Record<string, any>;
}

export const CatSchema = SchemaFactory.createForClass(Cat);

// 如果不习惯使用装饰器 可以 直接 monogose
// import * as mongoose from 'mongoose';
// export const CatSchema = new mongoose.Schema({
//   name: String,
//   age: Number,
//   breed: String,
// });

```

使用

```ts
// module
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

import { CatController } from './cat.controller';
import { CatService } from './cat.service';
import { Cat, CatSchema } from './schemas/cat.schema';

@Module({
  imports: [
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
    ),
  ],
  controllers: [CatController],
  providers: [CatService],
})
export class CatModule {}


// service
import { Injectable } from '@nestjs/common';
import { InjectConnection, InjectModel } from '@nestjs/mongoose';
import { Connection, Model } from 'mongoose';
import { Cat, CatDocument } from './schemas/cat.schema';

@Injectable()
export class CatService {
  // 注入model / 连接池（后者的功能要更强大 (https://mongoosejs.com/docs/api/connection.html#Connection())
  constructor(
    @InjectModel('Cat') private catModel: Model<CatDocument>,
    @InjectConnection() private connection: Connection,
  ) {}

  getHello(): string {
    return 'Hello World!';
  }

  async create(data: any): Promise<Cat> {
    const createCat = new this.catModel(data);
    return createCat.save();
  }
}

@Controller('cat')
export class CatController {
  constructor(private readonly catService: CatService) {}

  @Post('create')
  create(@Body() body: any) {
    return this.catService.create(body);
  }
}

```

其他的高级操作

```ts
// 如果需要 多数据库连接请使用
// core
  imports: [
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
      connectionName: 'testDB',
    }),
    MongooseModule.forRoot('mongodb://admin:123456@127.0.0.1:27017/testDB2', {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      authSource: 'admin',
      connectionName: 'testDB2',
    }),
  ],

// module
imports: [
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
      'testDB',
    ),
    MongooseModule.forFeature(
      [
        {
          name: Cat.name,
          schema: CatSchema,
        },
      ],
      'testDB2',
    ),
  ],

  // service
  @Injectable()
export class CatService {
  constructor(
    @InjectModel('Cat', 'testDB2') private catModel: Model<CatDocument>,
  ) {}

  getHello(): string {
    return 'Hello World!';
  }

  async create(data: any): Promise<Cat> {
    const createCat = new this.catModel(data);
    return createCat.save();
  }
}

```

mongoDB 中间件 和 plugin 的使用

```ts
// 间件是针对Schema层级的 （https://mongoosejs.com/docs/middleware.html）

 MongooseModule.forFeatureAsync([
      {
        name: 'Cat',
        useFactory: () => {
          const schema = CatsSchema;
          // 了解 mongoose 的朋友都知道 这个基本上就上mongoose 的基操
          schema.pre('save', () => console.log('Hello from pre save'));
          return schema;
        },
      },
    ]),

// 类似的 plugin 也是如此 https://mongoosejs.com/docs/plugins.html

// core 
// 要向所有 schema 中立即注册一个插件，调用Connection对象中的.plugin()方法。你可以在所有模型创建前访问连接。使用connectionFactory来实现：
MongooseModule.forRoot('mongodb://localhost/test', {
      connectionFactory: (connection) => {
        connection.plugin(require('mongoose-autopopulate'));
        return connection;
      },
    }),

// module
// 仅对 某个scheme
   MongooseModule.forFeatureAsync([
      {
        name: 'Cat',
        useFactory: () => {
          const schema = CatsSchema;
          schema.plugin(require('mongoose-autopopulate'));
          return schema;
        },
      },
    ]),
  ],
```

对于测试（单元测试什么的
**一般而言我们通常希望避免任何数据库连接**

解决方案是创建模拟model

```ts
@Module({
  providers: [
    CatsService,
    {
      provide: getModelToken('Cat'), // getModelToken @nestjs/mongoose 它返回一个 硬编码 实例对象
      useValue: catModel,
    },
  ],
})
export class CatsModule {}

```

对于数据的关联操作，请直接参考 <a href="https://juejin.cn/post/7104641797514592293">这里</a> 稳定

## 配置
>
> 一期有详细的描述 不做过多赘述

## 验证
>
> 我们讲一下细节问题 实际上 我们的 validation 和 pip紧密相关，不仅仅是 验证还可以做转换

Nest 会内置 9 个开箱即用 的pip,它们分两类

- ValidationPipe
- DefaultValuePipe
- ParseIntPipe
- ParseFloatPipe
- ParseBoolPipe
- ParseArrayPipe
- ParseUUIDPipe
- ParseEnumPipe
- ParseFilePipe

### Parse* 类型的Pip
>
> 这里的都是 Parse 开头的 pip 主要用来验证 值是否合法, 使用非常的简单

```ts
import {
  Controller,
  Get,
  HttpStatus,
  Param,
  ParseIntPipe,
  Query,
} from '@nestjs/common';
@Controller('pip')
export class PipController {
  @Get('t1/:id')
  test1(@Param('id', ParseIntPipe) id: number) {
    // 参数级别绑定
    return 't1';
  }

  @Get('t2/:id')
  test2(
    @Param(
      'id',
      new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }),
    )
    id: number,
  ) {
    // 使用实例 而不是class class会在ioc 容器内部处理掉
    return 't2';
  }

  @Get('t3')
  test3(@Query('id', ParseIntPipe) id: number) {
    return 'te';
  }
}
```

### Validation类型的Pip
>
> 实际上上述的 9个 只有两个是特例 ValidationPipe + DefaultValuePipe

要使用 nest内置的 ValidationPipe 需要install 两个依赖, 它的功能非常的强大

```shell
yarn add class-validator class-transformer
```

最常见的使用方式 全局自动加上 ValidationPipe，然后结合 class-validator 提供的装饰器，我们就可以非常快捷的写出 强大且合适的 pip

new ValidationPipe 有许多可选参数
|name|types|des|
|------|------|-----|
| enableDebugMessages | boolean | 如果设置为 true ，验证器会在出问题的时候打印额外的警告信息 |
| skipUndefinedProperties | boolean | 如果设置为 true ，验证器将跳过对所有验证对象中值为 null 的属性的验证 |
| skipNullProperties | boolean | 如果设置为 true ，验证器将跳过对所有验证对象中值为 null 或 undefined 的属性的验证 |
| skipMissingProperties | boolean | 如果设置为 true ，验证器将跳过对所有验证对象中缺失的属性的验证 |
| whitelist | boolean | 如果设置为 true ，验证器将去掉没有使用任何验证装饰器的属性的验证（返回的）对象 |
| forbidNonWhitelisted | boolean | 如果设置为 true ，验证器不会去掉非白名单的属性，而是会抛出异常 |
| forbidUnknownValues | boolean | 如果设置为 true ，尝试验证未知对象会立即失败 |
| disableErrorMessage | boolean | 如果设置为 true ,验证错误不会返回给客户端 |
| errorHttpStatusCode | number | 这个设置允许你确定在错误时使用哪个异常类型。默认抛出 BadRequestException |
| exceptionFactory | Function | 接受一个验证错误数组并返回一个要抛出的异常对象 |
| groups | string[] | 验证对象时使用的分组 |
| always | boolean | 设置装饰器选项 always 的默认值。默认值可以在装饰器的选项中被覆写 |
| strictGroups | boolean | 忽略在任何分组内的装饰器，如果 groups 没有给出或者为空 |
| dismissDefaultMessages | boolean | 如果设置为 true ，将不会使用默认消息验证，如果不设置，错误消息会始终是 undefined |
| validationError.target | boolean | 确定目标是否要在 ValidationError 中暴露出来 |
| validationError.value | boolean | 确定验证值是否要在 ValidationError 中暴露出来 |
| stopAtFirstError | boolean | 如果设置为 true ，对于给定的属性的验证会在触发第一个错误之后停止。默认为 false |

1. 简单实用

```ts
// 当然我们可以全局开 也可以 局限于 controller / 具体额路由上
app.useGlobalPipes(new ValidationPipe());

// 例子🌰 
@Post()
@UsePipes(new ValidationPipe())
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

// 新建DTO
import { IsEmail, IsNotEmpty } from 'class-validator';

export class TestDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;
}

// 注意不要到处 type TestDto
// ts类型会在运行时被擦除，记得用 import { CreateUserDto } 而不是 import type { CreateUserDto }

// 使用DTO
  @Post('t4')
  test4(@Body() testDto: TestDto) {
    return 't4';
  }

```

2. 控制白名单

```ts

// 如果你需要使用白名单 可以这样操作
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    // forbidNonWhitelisted:true 若你希望 遇到白名单的时候 返回错误 请开启它
  })
);

// 在DTO 中不加任何 装饰的 就是白名单的字段
export class TestDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  password: string;

  name: string
}

```

3. 进行转换

> 注意 paser* 开头的会自动转化

```ts
findOne(
  @Param('id', ParseIntPipe) id: number,
  @Query('sort', ParseBoolPipe) sort: boolean,
) {
  console.log(typeof id === 'number'); // true
  console.log(typeof sort === 'boolean'); // true
  return 'This action returns a user';
}

// 我们经常有这样的需求：create 的时候希望传递全部，modify的时候需要多传一个 id，有没有办法方便的实现呢？或者修改的时候某个字段又变成可选的了

// Nest 提供了 PartialType() 函数来让这个任务变得简单
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}

// PartialType() 函数是从 @nestjs/mapped-types 下面的例子 所有的参数都是可选的
export class UpdateCatDto extends PartialType(CreateCatDto) {}

// 如果你对 ts 熟悉的话，PickT、Omit...... 我就不多介绍了请看下面的代码
export class CreateCatDto {
  name: string;
  breed: string;
}
export class AdditionalCatInfo {
  color: string;
}
export class UpdateCatDto extends IntersectionType(
  CreateCatDto,
  AdditionalCatInfo,
) {}

// 若要验证Array 下面这种事不行的 请使用
@Post()
createBulk(@Body() createUserDtos: CreateUserDto[]) {
  return 'This action adds new users';
}

@Post()
createBulk(
  @Body(new ParseArrayPipe({ items: CreateUserDto }))
  createUserDtos: CreateUserDto[],
) {
  return 'This action adds new users';
}

// 如果你需要手动处理 array 比如 GET /?ids=1,2,3
@Get()
findByIds(
  @Query('id', new ParseArrayPipe({ items: Number, separator: ',' }))
  ids: number[],
) {
  return 'This action returns users by ids';
}


// 更多的 请看官方文档 https://docs.nestjs.com/techniques/validation



```

### 自定义Pip
>

## 序列化问题

## API多版本

## Job

## 队列问题

## 事件

## 压缩

## 文件上传

## 流处理文件

## Http模块

## Session绘画

## MVC

## 性能(Fastify)

## Service端的事件发送

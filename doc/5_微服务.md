# å¾®æœåŠ¡

## åŸºç¡€ä»‹ç»ï¼ˆå¤šä¸ªNestJS ç¨‹åºä¹‹é—´çš„è°ƒç”¨

> ä»‹ç»ä¸€ä¸‹ å¤šä¸ªNestç¨‹åºä¹‹é—´çš„è°ƒç”¨æ–¹å¼ å’Œå®ç°
> ä¸ºäº†æ¼”ç¤º åŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦è°ƒæ•´ä¸€ä¸‹ ç¨‹åºï¼ŒæŠŠå®ƒå˜æˆä¸€ä¸ª monorepo å·¥ç¨‹
> å…·ä½“åˆ°åº•å¦‚ä½• åŸºäºother_tech æˆ‘ä»¬æ–° æ‹‰ä¸€ä¸ªåˆ†æ”¯ å‘½åä¸º monorepo , å…·ä½“çš„é›†æˆæ–¹æ³• è¯·å‚è€ƒä¸ºçš„ å¦ä¸€ä¸ª githubå‚è€ƒ å“ªé‡Œæœ‰æ–‡ç« å’Œä¾‹å­ <https://github.com/BM-laoli/morerepo-test> (æœ‰å¯èƒ½learn è¿™ç§æ–¹å¼å·²ç»è¿‡æ—¶ï¼Œè¯·å‚è€ƒ )<https://juejin.cn/post/6964328103447363614#comment> æ¥åšpnpmä¸‹çš„ monorepo
>

## Pnpmä¸‹çš„monorepoå·¥ç¨‹æ”¹é€ 
>
> å‚è€ƒæ–‡ç«  <https://juejin.cn/post/6964328103447363614#comment>
>
> æ³¨æ„ ä»¥ä¸‹å†…å®¹ ï¼Œè¯·ä¸è¦ç›´æ¥æ‹¿å»ç”¨ï¼Œæˆ‘ä»…ä»…åšäº†æ¼”ç¤ºä¸ºäº†å›¾æ–¹ä¾¿ï¼Œåœ¨nestä¸­å¦‚æœä½ è¦å®æ–½ monorepo  è¯·çœ‹ nestå®˜æ–¹æ–‡æ¡£ï¼Œå®˜æ–¹æ–‡æ¡£æä¾›äº† ä¸€ä¸ªé€‚ç”¨ ä¸Nestçš„æ–¹æ¡ˆ <https://docs.nestjs.com/cli/monorepo>. å½“ç„¶ä½ å¦‚æœ æƒ³ä¸€æ„å­¤è¡Œ ï¼Œé‚£ä¹ˆ å“ˆå“ˆå“ˆ è¯·å‚è€ƒä¸‹é¢çš„æ–‡æ¡£

1. æ–°å»ºæ–‡ä»¶å¤¹ (å­é¡¹ç›®)

packages/m1 è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹ğŸ“ ä¸‹å°±æœ‰ä¸€ä¸ªæ–°çš„Nestjs é¡¹ç›®äº†

```shell
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ app.controller.ts
â”‚Â Â  â”œâ”€â”€ app.module.ts
â”‚Â Â  â”œâ”€â”€ app.service.ts
â”‚Â Â  â””â”€â”€ main.ts
â”œâ”€â”€ package.json
â”œâ”€â”€ nest-cli.json
â”œâ”€â”€ tsconfig.build.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ yarn.lock

```

æ³¨æ„æ”¹ä¸€ä¸‹å»æ‰ privateï¼Œå¦‚æœä½ éœ€è¦ è¯·æ”¹ä¸€ä¸‹åŒ…åï¼ˆå¤§éƒ¨åˆ†æƒ…å†µä¸‹ ä½ å¹¶ä¸éœ€è¦å»æ”¹ å› ä¸ºæˆ‘ä»¬æ˜¯ä¸¤ä¸ª ç‹¬ç«‹çš„ service, é™¤éä½ è¦åš libï¼Œè‹¥åšlib Nestå®˜æ–¹ä¹Ÿæœ‰è¯¦ç»†è¯´æ˜

```json
{
  "name": "nest-m1",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  // å»æ‰ "private": true,
}
```

2. pnpm åˆå§‹åŒ–

```shell
# åˆå§‹åŒ–
$ pnpm init -y
```

æ–°å»ºä¸€ä¸ª pnpm-workspace.yaml

```yaml
packages:
  # all packages in subdirs of packages/ and components/
  - 'packages/**'

```

3. ä¾èµ–å®‰è£…

```shell
# root ç›®å½•(æˆ‘ä»¬åŸæ¥ä» å¦ä¸€ä¸ªbranch è¿‡æ¥çš„ ä¸€æ ·installå°±å¥½äº†ï¼Œæ—¢å¾—install å‰ æŠŠ node_mmodules å…ˆå¹²æ‰ )
$ pnpm install -w  # (æ„æ€æ˜¯å…¨å±€ä¾èµ–)

# package/m1 ç›®å½•
$ pnpm install 
```

ç„¶å æŒ‰ç…§ç›¸åŒ çš„é€»è¾‘ æˆ‘ä»¬å†å» cv æ–‡ä»¶ï¼Œæ–°å»ºä¸€ä¸ª client æ–‡ä»¶å¤¹ è¿™æ ·å°±ç®—æå®šäº†ï¼

### Install

ä¸ç®¡æ˜¯ service / client éƒ½éœ€è¦ä½¿ç”¨è¿™ä¸ªä¾èµ–ï¼Œæ³¨æ„è¿™é‡Œè¯´çš„ service å’Œclient æ˜¯ æŒ‡ å¾®æœåŠ¡ å’Œ è¯·æ±‚ä»–çš„å…¶ä»–æœåŠ¡ï¼ˆç›¸å¯¹çš„ service | client

```shell
# $  npm i --save @nestjs/microservices
$ pnpm add @nestjs/microservices -w
```

### Service ç«¯

åœ¨ main å¼•å…¥

```ts
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      // é»˜è®¤æƒ…å†µNest ä½¿ç”¨TCPï¼Œ
      // options: {
      // host
      // port
      // retryAttempts é‡è¯•æ¶ˆæ¯æ¬¡æ•° é»˜è®¤ =0
      // retryDelay é‚®ä»¶é‡è¯•ä¹‹é—´çš„é—´éš”(ms)
      // },
    },
  );
```

å†controller  ä¸­å†™äº›é€»è¾‘

éœ€è¦ç‰¹åˆ«å¼ºè°ƒçš„æ˜¯ åœ¨Nestä¸­ å¾®æœåŠ¡é€šè¿‡**æ¨¡å¼**è¯†åˆ«æ¶ˆæ¯å’Œäº‹ä»¶

- è¯·æ±‚-å“åº”
- åŸºäºäº‹ä»¶

```ts
import {
  Controller,
  Get,
  Inject,
  RequestTimeoutException,
  Scope,
} from '@nestjs/common';
import {
  CONTEXT,
  Ctx,
  EventPattern,
  MessagePattern,
  NatsContext,
  Payload,
  RequestContext,
} from '@nestjs/microservices';
import { from, fromEvent, Observable } from 'rxjs';
import { AppService } from './app.service';

@Controller({
  scope: Scope.REQUEST,
})
export class AppController {
  constructor(
    private readonly appService: AppService,
    @Inject(CONTEXT) private ctx: RequestContext, // scope çš„æ—¶å€™
  ) {}

  // åœ¨Nestä¸­æœ‰ä¸¤ç§ å¾®æœåŠ¡çš„æ¨¡å¼æ¥è¯†åˆ«æ¶ˆæ¯å’Œäº‹ä»¶

  // ä¸‹é¢å°±æ˜¯ ä¸€ä¸ª (è¯·æ±‚-å“åº”)
  // æ³¨æ„å“ˆ è¿™ä¸ªdecorator åªåœ¨ controller ä¸­ç”¨
  @MessagePattern({ cmd: 'sum' })
  accumulate(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  // å¼‚æ­¥/Observable  ä¹Ÿæ˜¯æ”¯æŒçš„
  @MessagePattern({ cmd: 'sumSync' })
  accumulateSync(data: number[]): Promise<number> {
    return Promise.resolve((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'sumObservable' })
  accumulateObservable(data: number[]): Observable<number> {
    return from([1, 2, 3, 4]);
  }

  // ä»¥ä¸Šæ˜¯åŸºäº è¯·æ±‚+å“åº” çš„ ä¸‹é¢å’±ä»¬ æ¥è§‚å¯Ÿä¸€ä¸‹ åŸºäº äº‹ä»¶çš„
  @EventPattern('user_created')
  async cuser(data: any) {
    console.log(this.ctx.pattern);
    return 1;
  }
  // æˆ‘ä»¬å¯ä»¥ä¸ºä¸€ä¸ª äº‹ä»¶æ³¨å†Œå¤šä¸ªå¤„ç†ç¨‹åº ä»–ä»¬ä¼šä¾æ¬¡è§¦å‘
  @EventPattern('user_created')
  async cuser2(data: any) {
    return 2;
  }
  // å¦‚æœä½ éœ€è¦ä¸€äº› è¯·æ±‚çš„è¯¦ç»†ä¿¡æ¯ å¯ä»¥ä¼ é€’ä¸€ä¸ªcontext
  @MessagePattern('time.use.*') // é€šé…ç¬¦
  getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
    return new Date().toLocaleDateString();
  }
}

```

### Client ç«¯

å…³äºclient çš„é›†æˆç›¸å¯¹ç®€å•

æ³¨å…¥+ä½¿ç”¨å°±å¥½äº†

```ts
@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.TCP,
      },
    ]),
  ],
  controllers: [AppController, AppController2],
  providers: [AppService],
})
```

ä½¿ç”¨

```ts

@Controller('m1')
export class AppController {
  constructor(
    private readonly appService: AppService,
    @Inject('M1_SERVICE') private M1_client: ClientProxy,
  ) {}

  @Get()
  // t1(@Res() res: Response) {
  t1() {
    // this.M1_client.
    // return this.accumulate();
    // this.accumulate().subscribe((it) => {
    //   res.status(HttpStatus.OK).send(`${it}--`);
    // });
    // return this.accumulateSync();
    // return this.accumulateObservable();
    // return this.publish();
    return this.publish2();
  }

  // è¯·æ±‚å“åº”æ¨¡å¼
  accumulate() {
    const pattern = { cmd: 'sum' };
    const payload = [1, 2, 3];
    // æ³¨æ„è¿™ä¸ªé»˜è®¤éƒ½æ˜¯è¿”å›ä¸€ä¸ª "å†·Observable"
    return this.M1_client.send<number[]>(pattern, payload);
  }

  async accumulateSync() {
    const pattern = { cmd: 'sumSync' };
    const payload = [1, 2, 3, 4];

    const value = await lastValueFrom(
      this.M1_client.send<number[]>(pattern, payload),
    );

    return value;
  }

  accumulateObservable() {
    const pattern = { cmd: 'sumObservable' };
    const payload = [1, 2, 3, 4, 5];

    // æ¨¡æ‹Ÿæ“ä½œ å¯ä»¥ä½¿ç”¨ pipe(timeout(5000)) è¿™ä¸ªæ“ä½œç¬¦
    return this.M1_client.send<number[]>(pattern, payload);
  }

  // å‘é€äº‹ä»¶ æ³¨æ„å•Šè¿™ä¸ªè¿”å›çš„æ˜¯ ä¸€ä¸ªçƒ­çš„Observable
  async publish() {
    this.M1_client.emit<number>('user_created', 666);
  }

  async publish2() {
    this.M1_client.emit<number>('time.use.*', 2123);
  }
}
```

ä½ ä¹Ÿè®¸éœ€è¦æ³¨æ„çš„ä¸€ä¸ªç‚¹æ˜¯Scope çš„æƒ…å†µ

åœ¨ Nest ä¸­ï¼Œå‡ ä¹æ‰€æœ‰å†…å®¹éƒ½åœ¨ä¼ å…¥è¯·æ±‚ä¹‹é—´å…±äº«ï¼Œ
è¿™å¯èƒ½æ˜¯æ„æƒ³ä¸åˆ°çš„ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°æ®åº“çš„è¿æ¥æ± ï¼Œå…·æœ‰å…¨å±€çŠ¶æ€çš„å•ä¾‹æœåŠ¡ç­‰ã€‚
è¯·è®°ä½ï¼ŒNode.js ä¸éµå¾ªè¯·æ±‚/å“åº”å¤šçº¿ç¨‹æ— çŠ¶æ€æ¨¡å‹ï¼Œå…¶ä¸­æ¯ä¸ªè¯·æ±‚éƒ½ç”±å•ç‹¬çš„çº¿ç¨‹å¤„ç†ã€‚
å› æ­¤ï¼Œä½¿ç”¨å•ä¸€å®ä¾‹å¯¹äºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºæ˜¯å®Œå…¨å®‰å…¨çš„ã€‚ ä½†å¤šæ•°æƒ…å†µä¸‹ æˆ‘ä»¬ä¼šæœ‰ä¸€äº›ç¼“å­˜ç­–ç•¥ å¯¼è‡´ç¨‹åºè¡¨ç°å‡ºæ„æƒ³ä¸åˆ°çš„è¡Œä¸º æ•…æˆ‘ä»¬æŠŠæ¨¡å¼æ”¹äº†

```ts

@Controller({
  path: 'm2',
  scope: Scope.REQUEST,
})
export class AppController2 {
  constructor(
    @Inject('M1_SERVICE') private M1_client: ClientProxy,
    @Inject(CONTEXT) private ctx: RequestContext, // scope çš„æ—¶å€™
  ) {}

  @Get()
  t1() {
    // this.M1_client.
  }
  // è¯·æ±‚å“åº”æ¨¡å¼
  accumulate() {
    const pattern = { cmd: 'sum' };
    const payload = [1, 2, 3];
    // æ³¨æ„è¿™ä¸ªé»˜è®¤éƒ½æ˜¯è¿”å›ä¸€ä¸ª "å†·Observable"
    this.ctx.pattern;
    return this.M1_client.send<number[]>(pattern, payload);
  }
}
```

## é›†æˆå…¶å®ƒçš„å·¥å…·ğŸ”§
>
> æ¥ä¸‹é‡Œçš„å†…å®¹ ä¸»è¦å¢å¼º ä¸Šè¿°çš„ å¾®æœåŠ¡èƒ½åŠ›ï¼Œå› ä¸ºå¯ä»¥çœ‹å‡ºæ¥ï¼Œä¸Šè¿°çš„è®¾è®¡æ¯”è¾ƒç®€å•ï¼Œæ²¡æœ‰è€ƒè™‘åˆ° å¤šæœºå™¨ å¤šåç§°çš„æƒ…å†µï¼Œè€Œä¸”æˆ‘ä»¬ ä¹Ÿæ²¡æœ‰é…ç½® port å¦‚æœæ˜¯ k8s ç­‰å¤šæœºå™¨éƒ¨ç½²ï¼Œé‚£ä¹ˆæœåŠ¡å‘ç°è¯¥å¦‚ä½•å¤„ç†..... éƒ½æ²¡æœ‰è®²åˆ°, ä¸‹é¢çš„å·¥å…· æ—¨åœ¨å®Œå–„ ï¼Œå¾®æœåŠ¡é—´å­˜åœ¨çš„é—®é¢˜

### Redis
>
> Transport.REDISå¹¶åˆ©ç”¨äº† Redis çš„å‘å¸ƒ/è®¢é˜…åŠŸèƒ½ï¼Œ è®¾ç½®äº†ä¸€å¥—**å‘å¸ƒ/è®¢é˜…**çš„æ¶ˆæ¯ä¼ é€’èŒƒä¾‹ï¼Œ

å½“ç„¶ç‰¹æ€§(æœ‰ç‚¹ä¸ä¸è¶³) è¦è®²ä¸€ä¸‹

1. æ— æ³•æ˜ç¡®æœ€ç»ˆé‚£ä¸ªè®¢é˜…è€…ä¼šæ”¶åˆ°æ¶ˆæ¯(æ— æ³•ä¿è¯æ¶ˆæ¯æˆ–äº‹ä»¶å°†ç”±è‡³å°‘ä¸€ä¸ªæœåŠ¡å¤„ç†)
2. æ¯ä¸ªå¾®æœåŠ¡å¯ä»¥è®¢é˜…ä»»æ„æ•°é‡çš„é€šé“ï¼Œä¸€æ¬¡æ€§å¯è®¢é˜…å¤šä¸ªé€šé“
3. é€šè¿‡é€šé“äº¤æ¢çš„æ¶ˆæ¯æ˜¯ **å³å‘å³å¼ƒ**ï¼Œ å¦‚æœæ²¡æœ‰äººç”¨ é‚£ä¼šè¢«åˆ é™¤æ‰
4. ä¸€æ¡æ¶ˆæ¯ å¯ä»¥è¢«å¤šä¸ª è®¢é˜…è€…è®¢é˜…å’Œæ¥æ”¶

<img src="https://docs.nestjs.com/assets/Redis_1.png" />

åŸºç¡€çš„ç”¨æ³•å’Œå‰æ–‡æåˆ°çš„ æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼Œä¸è¿‡è¦æ³¨æ„ ä¸åŒçš„ç±»å‹(æˆ‘æ˜¯æŒ‡ ts å®šä¹‰çš„ç±»å‹ ä»–ä»¬æä¾›çš„åŠŸèƒ½ä¸ä¸€æ ·)

```ts
ï½ è¯¦ç»†è§ MicroserviceOptions .d.ts å®šä¹‰
/**
 * @publicApi
 */
export interface RedisOptions {
    transport?: Transport.REDIS;
    options?: {
        host?: string;
        port?: number;
        retryAttempts?: number;
        retryDelay?: number;
        serializer?: Serializer;
        deserializer?: Deserializer;
    } & IORedisOptions;
}
```

ä¸ºäº†æ¼”ç¤ºå¤šä¸ª microservices ä¹‹é—´çš„åŒæ—¶è®¢é˜…ï¼Œæˆ‘ä»¬æŠŠ M1(åœ¨ä¸ŠèŠ‚ä¸­å®ƒä½œä¸ºä¸€ä¸ªmicroservices ) , å†cvä¸€ä»½ é‡å‘½åä¸º m2æ–‡ä»¶å¤¹ï¼Œ ç„¶årun

å®‰è£…å¿…è¦çš„ä¾èµ–

```shell
npm i --save ioredis
pnpm add ioredis -w
```

ä¿®æ”¹ service å¹¶ä¸”åŠ ä¸€ä¸ª è®¢é˜…å™¨

```ts
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.REDIS,
      options: {
        host: 'localhost',
        port: 6379,
      },
    },
  );

++++
  // redis
  @MessagePattern('notifications')
  getNotifications(@Payload() data: number[], @Ctx() context: RedisContext) {
    console.log(`Channel: ${context.getChannel()}`); // notifications
    console.log(222);
  }
```

ä¿®æ”¹ client æ¢ä¸€ä¸ª äº‹ä»¶å‘å¸ƒ

```ts
  ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.REDIS,
        options: {
          host: 'localhost',
          port: 6379,
        },
      },
    ]),
  ++++
  // redis
  async publishToRedis() {
    this.M1_client.emit<number>('notifications', 2123);
  }
```

æœ€åè¯´ä¸€ä¸‹å®ƒçš„åº”ç”¨åœºæ™¯

åœ¨å¾®æœåŠ¡æ¶æ„ä¸­ Redisé€šå¸¸ç”¨ä½œæ¶ˆæ¯é˜Ÿåˆ—ï¼Œé€‚åˆå¤„ç†é«˜å¹¶å‘çš„æ¶ˆæ¯ä¼ é€’ï¼›
ä½†æ˜¯Redisä¸æ˜¯ä¸“é—¨è®¾è®¡ç”¨æ¥å¤„ç†æ¶ˆæ¯ä¼ é€’çš„ï¼Œåœ¨éœ€è¦ä¿è¯æ¶ˆæ¯é¡ºåºçš„å‰æä¸‹ redis ä¹Ÿè®¸ä¸æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚ ä¸‹é¢çš„å‡ ç§åœºæ™¯å¯ä»¥ä½¿ç”¨

|åº”ç”¨åœºæ™¯|des|
|----|----|
|å¼‚æ­¥ä»»åŠ¡å¤„ç†| å°†éœ€è¦å¼‚æ­¥æ‰§è¡Œçš„ä»»åŠ¡æ”¾å…¥Redisæ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œå¤„ç†ä»»åŠ¡çš„å·¥ä½œè¿›ç¨‹ä»é˜Ÿåˆ—ä¸­è¯»å–ä»»åŠ¡ï¼Œå®Œæˆåå°†ç»“æœå†™å›Redisæˆ–å…¶ä»–å­˜å‚¨ç³»ç»Ÿä¸­ã€‚è¿™ç§æ–¹å¼å¯ä»¥é¿å…ä»»åŠ¡å¤„ç†è¿‡ç¨‹ä¸­é˜»å¡ä¸»çº¿ç¨‹ï¼Œæé«˜ç³»ç»Ÿçš„å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚ |
| å®æ—¶æ¶ˆæ¯æ¨é€ | é€šè¿‡Redisæ¶ˆæ¯é˜Ÿåˆ—å°†å®æ—¶æ¶ˆæ¯æ¨é€ç»™å®¢æˆ·ç«¯ï¼Œä¾‹å¦‚åœ¨çº¿èŠå¤©ã€è‚¡ç¥¨è¡Œæƒ…ç­‰ã€‚æ¶ˆæ¯å‘å¸ƒè€…å°†æ¶ˆæ¯å†™å…¥Redisæ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œè®¢é˜…è€…é€šè¿‡è®¢é˜…Redisæ¶ˆæ¯é¢‘é“æˆ–ä½¿ç”¨Redisçš„PUBLISHå‘½ä»¤æ¥æ¥æ”¶æ¶ˆæ¯ã€‚ |
|å¼‚æ­¥ä»»åŠ¡å¤„ç† | å°†åº”ç”¨äº§ç”Ÿçš„æ—¥å¿—ä¿¡æ¯å†™å…¥Redisæ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œä½¿ç”¨å·¥ä½œè¿›ç¨‹ä»é˜Ÿåˆ—ä¸­è¯»å–æ—¥å¿—å¹¶è¿›è¡Œå¤„ç†ï¼Œä¾‹å¦‚è¿‡æ»¤ã€åˆ†æã€å­˜å‚¨ç­‰ã€‚è¿™ç§æ–¹å¼å¯ä»¥é¿å…æ—¥å¿—å¤„ç†è¿‡ç¨‹ä¸­é˜»å¡ä¸»çº¿ç¨‹ï¼Œæé«˜ç³»ç»Ÿçš„æ€§èƒ½å’Œå¯é æ€§ã€‚ |

### MQTT
>
> MQTTï¼ˆæ¶ˆæ¯é˜Ÿåˆ—é¥æµ‹ä¼ è¾“ï¼‰æ˜¯ä¸€ç§å¼€æºçš„è½»é‡çº§æ¶ˆæ¯ä¼ é€’å .
> åŸºäº MQTT æ„å»ºçš„é€šä¿¡ç³»ç»Ÿç”± å‘å¸ƒæœåŠ¡å™¨ã€ä»£ç†å’Œä¸€ä¸ªæˆ–å¤šä¸ªå®¢æˆ·ç«¯ç»„æˆã€‚å®ƒä¸“ä¸ºå—é™è®¾å¤‡å’Œä½å¸¦å®½ã€é«˜å»¶è¿Ÿæˆ–ä¸å¯é çš„ç½‘ç»œè€Œè®¾è®¡ã€‚

æ€»ä½“æ¥è¯´ å®ƒæˆæœ¬ä½ è€Œä¸”æ•ˆæœå¥½ å»¶è¿Ÿä½ï¼Œéå¸¸é€‚åˆç”¨åœ¨ ç‰©è”ç½‘, ä¼ æ„Ÿå™¨ å’ŒæœåŠ¡å™¨çš„é€šä¿¡

é¦–å…ˆæˆ‘ä»¬éœ€è¦æ„å»ºè¿™æ ·çš„ä¸€å¥—åŸºç¡€è®¾æ–½ ï¼Œæˆ‘ä»¬ä½¿ç”¨docker å»æ„å»º
ï¼Œå†æ¬¡å¼ºè°ƒ**å› ä¸ºMQTTæ˜¯ä¸€ä¸ªåè®®ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ­å»ºä¸€ä¸ªæ”¯æŒMQTTåè®®çš„æœåŠ¡å™¨ï¼Œä½¿æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯èƒ½å¤Ÿé€šè¿‡è¿™ä¸ªMQTTæœåŠ¡å™¨ï¼ˆbrokerï¼‰è¿›è¡Œæ¶ˆæ¯è½¬å‘ã€é€šä¿¡**

EMQ X (Erlang/Enterprise/Elastic MQTT Broker) æ˜¯åŸºäº Erlang/OTP å¹³å°å¼€å‘çš„å¼€æºç‰©è”ç½‘ MQTT æ¶ˆæ¯æœåŠ¡å™¨ï¼Œå®ƒæ˜¯ç›®å‰æ¯”è¾ƒå¥½ MQTT æœåŠ¡äº§å“ï¼Œå¤šäº†ä¸è¯´äº† è‡ªå·±å»searchå§

```shell
$ docker pull emqx
$ docker run -d --name emqx -p 1883:1883 -p 18083:18083 emqx/emqx

# å®Œäº‹ä¹‹å ç®¡ç†ç«¯ åœ¨ :18083  admin/public ä¸­ç™»å½•ç®¡ç† 

# åœ¨å·¥ç¨‹ root ç›®å½•ä¸‹å®‰è£… mqtt ä¾èµ–
$  pnpm add mqtt -w
```

æ¥ä¸‹æ¥ å¼€å§‹é›†æˆ, æŠŠservice å’Œ clientçš„åè®®æ”¹äº†

```ts
ï½ service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.MQTT,
      options: {
        url: 'mqtt://localhost:1883',
      },
    },
  );

ï½ client
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.MQTT,
        options: {
          url: 'mqtt://localhost:1883',
         
        },
      },
    ]),
```

ç„¶åæˆ‘ä»¬ å¤šåŠ ä¸€äº›å‘å¸ƒå’Œè®¢é˜…çš„ä»£ç ( å®é™…ä¸Šå’Œ ä¹‹å‰çš„é‚£äº›ç±»å‹ï¼Œä»£ç éƒ½æ˜¯ä¸€æ ·çš„ç‰ˆå¼ )

```ts
ï½ service
  // MQTT
  // @MessagePattern('sensors/+/temperature/+') æ”¯æŒé€šé…ç¬¦
  @MessagePattern('notificationsMQTT')
  getNotificationsMQTT(@Payload() data: number[], @Ctx() context: MqttContext) {
    console.log(`Topic: ${context.getTopic()}`); // notifications
    console.log(222);

    // å¦‚æœä½ éœ€è¦è®¿é—® åŸå§‹çš„mqttæ•°æ®åŒ… è¯·ä½¿ç”¨
    console.log(context.getPacket());
  }

  // MQTT2
  @MessagePattern('replace-emoji')
  replaceEmoji(@Payload() data: string, @Ctx() context: MqttContext): string {
    const {
      properties: { userProperties },
      // å¦‚æœä½ è¿™é‡Œ æ˜¯ä¸€ä¸ªundefined è®°å¾—å»ç»™ä½ çš„ é…ç½® åŠ ä¸€ä¸ª åè®®ç‰ˆæœ¬  protocolVersion: 5,
      // issues  https://github.com/nestjs/nest/issues/10016
    } = context.getPacket();

    console.log('2');

    return userProperties['x-version'] === '1.0.0' ? 'ğŸ±' : 'ğŸˆ';
  }

ï½ Client
// MQTT
  publishToMQTT() {
    // this.M1_client.emit<number>('notificationsMQTT', {
    //   name: 6666,
    // });

    // é…ç½® æ¶ˆæ¯é€‰é¡¹
    const userProperties = { 'x-version': '1.0.0' };
    const record = new MqttRecordBuilder(':cat:')
      .setProperties({ userProperties })
      .setQoS(1)
      .build();
    console.log(record);

    return this.M1_client.send('replace-emoji', record);
  }

```

### NATS
>
> è¿™ä¸ªä¸œè¥¿ ä¹Ÿæ˜¯ä¸€ä¸ªæ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ,ç›®å‰æœ€æ–°ç‰ˆæœ¬ ä½¿ç”¨Goå¼€å‘ æ€§èƒ½éå¸¸çš„NBï¼Œå®ƒæ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼çš„æ¶ˆæ¯ä¸­é—´ä»¶

åŒæ ·çš„ä»£ç† å®ƒä¹Ÿæ˜¯æœ‰ç›´æ¥çš„æ¶ˆæ¯åè®®ï¼Œè¯·å…ˆå®‰è£… è¿™ä¸ªç³»ç»Ÿ

```shell
$ docker pull nats
$ docker run -d --name nats-main -p 4222:4222 -p 8222:8222 nats

# å®‰è£…ndoejs ä¾èµ–
$ pnpm add nats -w
```

ç‰¹åˆ«è¦è¯´æ˜çš„: Nest Transport.NATS ä¸ä½¿ç”¨ NATS å†…ç½®çš„ è¯·æ±‚-å“åº” ä¼ è¾“æœºåˆ¶ï¼Œæ— è®ºå“åº”çš„Serviceåœ¨ä»€ä¹ˆåœ°æ–¹ï¼Œå®ƒéƒ½ä¼šåŠ¨æ€çš„è¿”å› åˆ° clientç¨‹åº.

ä½†å¯¹äº åŸºäºäº‹ä»¶ çš„ä¼ è¾“æ¨¡å¼ï¼ŒNest ä½¿ç”¨NATS å†…ç½®çš„æœºåˆ¶ï¼Œå¦‚æœå‘å¸ƒä¸€ä¸ªåŸºäºä¸»é¢˜çš„messageæ—¶ï¼Œè®¢é˜…è¿™ä¸ªä¸»é¢˜çš„ éƒ½ä¼šæ”¶åˆ°æ­¤æ¶ˆæ¯( è¿™ç§ä¸€å¯¹å¤š è¢«ç§°ä¸º æ‰‡å‡º)

ç„¶å NATS æä¾›äº†ä¸€ä¸ªå†…ç½®çš„ åˆ†å¸ƒå¼é˜Ÿåˆ— ï¼Œå¦‚æœè¦ä½¿ç”¨æƒ…å†µ ä¸‹é¢çš„ä»£ç 

```ts
~ Service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.NATS,
      options: {
        servers: ['nats://localhost:4222'],
      },
    },
  );

~ Client
  ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.NATS,
        options: {
          servers: ['nats://localhost:4222'],
        },
      },
    ]),
```

ç„¶åå°±æ˜¯å¤šåŠ å‡ ä¸ª è®¢é˜… å’Œpublish æ–¹æ³•

```ts
~ Service
  // NTAS
  @MessagePattern('notificationsNATS')
  notificationsNATS(@Payload() data: number[], @Ctx() context: NatsContext) {
    console.log(`Subject: ${context.getSubject()}`);
  }

  // NATS å¯ä»¥è®¾ç½® æ ‡å¤´
  @MessagePattern('replace-emoji-NATS')
  replaceEmojiNATS(
    @Payload() data: string,
    @Ctx() context: NatsContext,
  ): string {
    const headers = context.getHeaders();
    // è¿™ä¸ªè¿”å›æ—¶ä¸€ä¸ªæ˜¯get ä¸è¦ç›¸ä¿¡å®˜æ–¹ç»™å†™çš„ headers['x-version']
    return headers.get('x-version') === '1.0.0' ? 'ğŸ±' : 'ğŸˆ';
  }

~  Client
import * as nats from 'nats';

  // NAST
  publishToNAST() {
    // this.M1_client.emit<number>('notificationsNATS', {
    //   name: 6666,
    // });

    // é…ç½® æ¶ˆæ¯é€‰é¡¹
    const headers = nats.headers();
    headers.set('x-version', '1.0.0');
    const record = new NatsRecordBuilder(':cat:').setHeaders(headers).build();

    this.M1_client.send('replace-emoji-NATS', record).subscribe((it) => {
      console.log(it);
    });
  }
```

### RabbitMQ
>
> RabbitMQæ˜¯ä¸€ä¸ªå¼€æºçš„æ¶ˆæ¯ä»£ç†ï¼Œå®ƒæ”¯æŒå¤šç§æ¶ˆæ¯åè®®ã€‚

è¿˜æ˜¯ä¸€æ · æˆ‘ä»¬å…ˆå®‰è£…å®ƒ

```shell
$ docker pull rabbitmq:3.11-management
$ docker run -d --hostname my-rabbit --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3.11-management

# å®‰è£…nodejs ä¾èµ–
$ pnpm install amqplib amqp-connection-manager -w
```

:15672 æ˜¯å®ƒçš„ç®¡ç†prot é»˜è®¤ç”¨æˆ·åæ˜¯ guest , guest

å¤§éƒ¨åˆ†ä½¿ç”¨æ–¹æ³•å’Œæ–¹æ³•å’Œ å‰é¢çš„æ¶ˆæ¯ç³»ç»Ÿä½¿ç”¨æ–¹å¼æ˜¯ ä¸€æ ·çš„ï¼ŒRabbitMQé…ç½®ä¸Šæœ‰ æ¯”è¾ƒå¤§çš„åŒºåˆ«

| é€‰é¡¹ | ä½œç”¨ |
| ---- | ---- |
| urls  | è¿æ¥ç½‘å€ |
| queue  | æœåŠ¡å™¨å°†ä¾¦å¬çš„é˜Ÿåˆ—åç§° |
| prefetchCount  | è®¾ç½®é€šé“çš„é¢„å–è®¡æ•° |
| isGlobalPrefetchCount  | å¯ç”¨æ¯é€šé“é¢„å– |
| noAck  | å¦‚æœå¯ç”¨æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼false |
| queueOptions  | å…¶ä»–é˜Ÿåˆ—é€‰é¡¹ï¼ˆåœ¨æ­¤å¤„é˜…è¯»æ›´å¤šå†…å®¹ï¼‰) |
| socketOptions  | å…¶ä»–å¥—æ¥å­—é€‰é¡¹ï¼ˆåœ¨æ­¤å¤„é˜…è¯»æ›´å¤šå†…å®¹ï¼‰) |
| headers  | è¦ä¸æ¯æ¡æ¶ˆæ¯ä¸€èµ·å‘é€çš„æ ‡å¤´ |

æˆ‘ä»¬å…ˆæŠŠ è¿æ¥æ–¹å¼æ”¹äº†

```ts
~ Service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.RMQ,
      options: {
        urls: ['amqp://localhost:5672'],
        queue: 'cats_queue',
        queueOptions: {
          durable: false,
          // åœ¨RabbitMQä¸­ï¼Œé˜Ÿåˆ—å¯ä»¥è¢«å£°æ˜ä¸ºæŒä¹…åŒ–ï¼ˆdurableï¼‰æˆ–éæŒä¹…åŒ–ï¼ˆdurable: falseï¼‰ã€‚å½“é˜Ÿåˆ—è¢«å£°æ˜ä¸ºæŒä¹…åŒ–æ—¶ï¼Œ
          // å®ƒå°†åœ¨RabbitMQæœåŠ¡å™¨é‡å¯åä»ç„¶å­˜åœ¨ã€‚ä½†æ˜¯ï¼Œå¦‚æœé˜Ÿåˆ—è¢«å£°æ˜ä¸ºéæŒä¹…åŒ–ï¼Œé‚£ä¹ˆå®ƒå°†åœ¨æœåŠ¡å™¨é‡å¯åæ¶ˆå¤±ã€‚
          // å› æ­¤ï¼Œå¦‚æœæ‚¨å¸Œæœ›æ‚¨çš„é˜Ÿåˆ—åœ¨æœåŠ¡å™¨é‡å¯åä»ç„¶å­˜åœ¨ï¼Œæ‚¨åº”è¯¥å°†å…¶å£°æ˜ä¸ºæŒä¹…åŒ–ã€‚
        },
      },
    },
  );

~ Client
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.RMQ,
        options: {
          urls: ['amqp://localhost:5672'],
          queue: 'cats_queue',
          queueOptions: {
            durable: false,
          },
        },
      },
    ]),

```

ç„¶åæˆ‘ä»¬ç®€å•çš„å±•ç¤ºå®ƒçš„ä½¿ç”¨

```ts
~ Service
 // RMQ
  @MessagePattern('notificationsRMQ')
  getNotificationsRMQ(@Payload() data: number[], @Ctx() context: RmqContext) {
    console.log(`Pattern: ${context.getPattern()}`);
    console.log(`Pattern: ${context.getMessage()}`); // è·å–åŸå§‹æ•°æ®
    // è¦æ£€ç´¢å¯¹ RabbitMQ é€šé“çš„å¼•ç”¨ è¯·å‚è€ƒ
    console.log(context.getChannelRef());
    console.log(data);

    // å¦‚æœ æˆ‘ä»¬è®¾ç½®äº† noAck: false,éœ€è¦ æ‰‹åŠ¨çš„checkä¸€ä¸‹
    context.getChannelRef().ack(context.getMessage());
    return '666';
  }

  // RMQ åŒæ ·çš„ä¹Ÿæ”¯æŒ è®¾ç½®å¤´ä¿¡æ¯ç­‰æ“ä½œ
  @MessagePattern('replace-emoji-RMQ')
  replaceEmojiRMQ(@Payload() data: string, @Ctx() context: RmqContext): string {
    const {
      properties: { headers },
    } = context.getMessage();
    return headers['x-version'] === '1.0.0' ? 'ğŸ±' : 'ğŸˆ';
  }

~ Client
  // RMQ
  publishToRMQ() {
    this.M1_client.send('notificationsRMQ', {
      name: 'RMQ',
    }).subscribe((it) => {
      console.log(it);
    });
    // const message = ':cat:';
    // const record = new RmqRecordBuilder(message)
    //   .setOptions({
    //     headers: {
    //       ['x-version']: '1.0.0',
    //     },
    //     priority: 3,
    //   })
    //   .build();

    // this.M1_client.send('replace-emoji-RMQ', record).subscribe((it) => {
    //   console.log(it);
    // });
  }
```

### Kafka
>
> è­¦å‘Š æ­¤å°èŠ‚å†…å®¹**å®Œå…¨è¶…çº² 200%**ï¼Œå¦‚æœä½ è¦å°è¯• ï¼Œè¯·åšå¥½å¿ƒç†å‡†å¤‡ï¼Œ
> Kafka æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼æµå¤„ç†å¹³å°ï¼Œå®ƒèƒ½å¤Ÿå®ç°å®æ—¶çš„äº‹ä»¶é©±åŠ¨åº”ç”¨ç¨‹åºå¼€å‘ã€‚å…·æœ‰é«˜ååé‡ã€ä½å»¶è¿Ÿçš„ç­‰ç‰¹ç‚¹ ä¸Apache Stormå’ŒSparkå¾ˆå¥½åœ°é›†æˆåœ¨ä¸€èµ·ï¼Œç”¨äºå®æ—¶æµæ•°æ®åˆ†æã€‚

ä¸‹é¢çš„å®ƒçš„å…³é”®çš„ä¸‰ä¸ªåŠŸèƒ½

- å‘å¸ƒå’Œè®¢é˜…è®°å½•æµï¼Œç±»ä¼¼äºæ¶ˆæ¯é˜Ÿåˆ—æˆ–ä¼ä¸šé‚®ä»¶ç³»ç»Ÿã€‚
- ä»¥å®¹é”™æŒä¹…çš„æ–¹å¼å­˜å‚¨è®°å½•æµã€‚
- åœ¨è®°å½•æµå‘ç”Ÿæ—¶å¯¹å…¶è¿›è¡Œå¤„ç†ã€‚

å…ˆåœ¨ docker ä¸Šæ„å»ºä¸€ä¸ª kafka åŸºç¡€è®¾æ–½ï¼ˆè¿™é‡Œæ˜¯è¸©å‘çš„ä¸€ä¸ªåœ°æ–¹ <a href="https://www.cnblogs.com/hellxz/p/why_cnnect_to_kafka_always_failure.html">Docker åˆ°åº•å¦‚ä½•éƒ¨ç½² Kafka</a>ï¼‰

docker-compose.yml

```yml
version: "3.0"
services:
    zookeeper:
        image: zookeeper:3.5.5
        restart: always
        container_name: zookeeper
        ports:
            - "2181:2181"
        expose:
            - "2181"
        environment:
            - ZOO_MY_ID=1
    kafka:
        image: wurstmeister/kafka:2.12-2.2.1
        restart: always
        container_name: kafka
        environment:
            - KAFKA_BROKER_ID=1
            - KAFKA_LISTENERS=PLAINTEXT://kafka:9090
            - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
            - KAFKA_MESSAGE_MAX_BYTES=2000000
        ports:
            - "9090:9090"
        depends_on:
            - zookeeper
```

run

```shell
$ docker-compose up -d
Creating network "kafka_default" with the default driver
Creating kafka_zookeeper_1 ... done
Creating kafka_kafka_1 ... done

# Nodejs ä¾èµ–
$ pnpm add kafkajs -w

```

#### ç†è®ºå’Œæ¦‚å¿µ
>
> åœ¨æ­£å¼å¼€å§‹å‰ éœ€è¦æœ‰å‡ ç‚¹è¯´æ˜

ä¸äº†è§£ Kafkaçš„ä¸€å®šä¸€å®šè¦å…¥é—¨ <a href="https://zhuanlan.zhihu.com/p/74063251">Kafka</a> è¦ä¸ç„¶ æ¥ä¸‹æ¥ä½ å°±éå¸¸çš„è’™åœˆï¼

1. Inject çš„æ—¶å€™ ä½¿ç”¨çš„æ˜¯ ClientKafka è€Œä¸æ˜¯ ClientProxy

2. Kafka ä½¿ç”¨ ä¸¤ä¸ªä¸»é¢˜ æ¥å¤„ç† â€œè¯·æ±‚å“åº”â€æ¨¡å¼; ClientKafka.send() è¿™ä¸ªæ–¹æ³• é€šè¿‡å°†  **â€œcorrelation idâ€ã€ â€œreply topicâ€ å’Œ â€œ reply partition  â€** ä¸è¯·æ±‚æ¶ˆæ¯ç›¸å…³è”æ¥ å‘é€å¸¦æœ‰ è¿”å›åœ°å€çš„æ¶ˆæ¯ã€‚ è¿™éœ€è¦å®ä¾‹åœ¨å‘é€æ¶ˆæ¯ä¹‹å‰ ï¼Œå¿…é¡»è®¢é˜…å›å¤ä¸»é¢˜å¹¶åˆ†é…åˆ°è‡³å°‘ä¸€ä¸ªåˆ†åŒºã€‚æœ‰ç‚¹æ™•æ˜¯å§ï¼Ÿè¯´äººè¯å°±æ˜¯ å¿…é¡»è¦ **æœ‰è®¢é˜…åŠ¨ä½œ**

æ¯ä¸ª ç¨‹åºè‡³å°‘ æœ‰ä¸€ä¸ª topic å’Œ partitionï¼Œè¦ä¸ç„¶ä¼šæŠ¥é”™ ;

3. Incoming & Outgoing (ä¼ å…¥/ä¼ å‡º),

Nest ä»¥å¯¹è±¡çš„å½¢å¼æ¥æ”¶ä¼ å…¥çš„ Kafka æ¶ˆæ¯ï¼Œå…¶ä¸­åŒ…å« ã€ å’Œå…·æœ‰ ç±»å‹å€¼çš„å±æ€§ã€‚ç„¶åï¼ŒNest é€šè¿‡å°†ç¼“å†²åŒºè½¬æ¢ä¸ºå­—ç¬¦ä¸²æ¥è§£æè¿™äº›å€¼ã€‚

åœ¨å‘å¸ƒäº‹ä»¶æˆ–å‘é€æ¶ˆæ¯æ—¶ï¼ŒNestå°†åœ¨åºåˆ—åŒ–è¿‡ç¨‹ä¹‹åå‘é€ä¼ å‡ºçš„Kafkaæ¶ˆæ¯ã€‚è¿™å‘ç”Ÿåœ¨ä¼ é€’ç»™ClientKafkaçš„emit()å’Œsend()æ–¹æ³•çš„å‚æ•°ä¸Šï¼Œæˆ–ä»@MessagePatternæ–¹æ³•çš„è¿”å›å€¼ä¸Šã€‚è¯¥åºåˆ—åŒ–é€šè¿‡ä½¿ç”¨JSON.stringify()æˆ–toString()åŸå‹æ–¹æ³•æ¥â€œå­—ç¬¦ä¸²åŒ–â€ä¸æ˜¯å­—ç¬¦ä¸²æˆ–ç¼“å†²åŒºçš„å¯¹è±¡ã€‚

4, å‘æ¶ˆæ¯çš„æ—¶å€™ è¦å¸¦æœ‰keyå’Œ value ï¼Œè¿™å¯¹äºæ»¡è¶³å…±åŒåˆ†åŒºè¦æ±‚éå¸¸é‡è¦

```ts
return {
      headers: {
        realm
      },
      key: heroId,
      value: items
    }
```

5. å‘½åçº¦å®š

Kafka å¾®æœåŠ¡ç»„ä»¶åœ¨ å’Œ é€‰é¡¹ä¸Šé™„åŠ äº†å„è‡ªè§’è‰²çš„æè¿°ï¼Œä»¥é˜²æ­¢ Nest å¾®æœåŠ¡å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç»„ä»¶ä¹‹é—´çš„å†²çª,

```ts
const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      clientId: 'hero', // hero-server
      brokers: ['localhost:9092'],
    },
    consumer: {
      groupId: 'hero-consumer' // hero-consumer-server
    },
  }
});
// å®¢æˆ·ç«¯ä¹Ÿéœ€è¦è®¾ç½® 
```

6. å…³äºå¤±è´¥çš„æ—¶å€™é‡è¯•

è¯·ä½¿ç”¨ throw new KafkaRetriableException('...'); å®ƒä¼šè¿›è¡Œé‡è¯•

7. æäº¤åç§»é‡

ä»€ä¹ˆæ˜¯ åç§»é‡ ï¼Ÿ

åœ¨ Kafka ä¸­ï¼Œåç§»é‡ï¼ˆoffsetï¼‰æ˜¯æŒ‡åˆ†åŒºä¸­æ¯æ¡æ¶ˆæ¯çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚å®ƒè¡¨ç¤ºäº†æ¶ˆæ¯åœ¨åˆ†åŒºä¸­çš„ä½ç½®ã€‚æ¶ˆè´¹è€…å¯ä»¥ä½¿ç”¨åç§»é‡æ¥è·Ÿè¸ªå®ƒå·²ç»æ¶ˆè´¹äº†å“ªäº›æ¶ˆæ¯ã€‚å¦‚æœæ¶ˆè´¹è€…å´©æºƒæˆ–é‡æ–°å¯åŠ¨ï¼Œå®ƒå¯ä»¥ä»ä¸Šæ¬¡æäº¤çš„åç§»é‡å¤„ç»§ç»­è¯»å–æ•°æ®ã€‚

åœ¨ä½¿ç”¨ Kafka æ—¶ï¼Œæäº¤åç§»é‡è‡³å…³é‡è¦ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¶ˆæ¯å°†åœ¨ç‰¹å®šæ—¶é—´åè‡ªåŠ¨æäº¤ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—® KafkaJS æ–‡æ¡£ã€‚Nest æä¾›äº†ä¸€ç§æ‰‹åŠ¨æäº¤åç§»é‡çš„æ–¹æ³•ï¼Œå…¶å·¥ä½œæ–¹å¼ç±»ä¼¼äº KafkaJS å®ç°.

```ts
const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
  transport: Transport.KAFKA,
  options: {
    client: {
      brokers: ['localhost:9092'],
    },
    run: {
      autoCommit: false
    }
  }
});

@EventPattern('user.created')
async handleUserCreated(@Payload() data: IncomingMessage, @Ctx() context: KafkaContext) {
  // business logic
  
  const { offset } = context.getMessage();
  const partition = context.getPartition();
  const topic = context.getTopic();
  await this.client.commitOffsets([{ topic, partition, offset }])
}
```

#### ä»£ç 
>
> äº†è§£å®ŒåŸºç¡€ç†è®ºä¹‹å æˆ‘ä»¬æ¥çœ‹ç›¸å…³çš„ä»£ç 

è°ƒæ•´åè®® (æˆ‘ä»¬æ–°å®¶å¼€äº†ä¸€ä¸ªæ–‡ä»¶ ä¸èƒ½ä½¿ç”¨åŸæ¥çš„ï¼ŒåŸå› è¯·çœ‹ç¬¬äºŒç‚¹Â·æ²¡æœ‰äººè®¢é˜…ç¨‹åºæ˜¯ä¼šæŠ›å‡ºerrorçš„Â· )

```ts
ï½ Service 
 const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.KAFKA,
      options: {
        client: {
          clientId: 'hero',
          brokers: ['192.168.101.3:9090'],
        },
        consumer: {
          groupId: 'hero-consumer',
        },
      },
    },
  );
  await app.listen();

~ Client
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.KAFKA,
        options: {
          client: {
            clientId: 'hero',
            brokers: ['192.168.101.3:9090'],
          },
          consumer: {
            groupId: 'hero-consumer',
          },
        },
      },
    ]),
```

å…¶ä»–ç›¸å…³ä»£ç ä¾‹å­

```ts
ï½ KafkaService
  import * as util from 'util';
  import { KafkaMessage } from 'kafkajs';

  interface Dragon {
    id: number;
    name: string;
  }

  type KillDragonMessage = Omit<KafkaMessage, 'value'> & {
    value: Pick<Dragon, 'id'>;
  };

  // Simplified example: move method implementations to the service ofc
  @Controller()
  export class KafkaController {
    private readonly logger = new Logger(KafkaController.name);

    @MessagePattern('hero.kill.dragon')
    onKillDragon(
      @Payload() message: KillDragonMessage,
      @Ctx() context: KafkaContext,
    ) {
      const dragons = [
        { id: 1, name: 'Smaug' },
        { id: 2, name: 'Ancalagon The Black' },
        { id: 3, name: 'Glaurung' },
      ];
      this.logger.log(`[hero.kill.dragon] message = ${util.inspect(message)}`);

      // ç®€å•çš„ä½¿ç”¨ ç›´æ¥è¿”å› ç»“æœ
      // return dragons;

      // è·å– åŸå§‹ä¿¡æ¯
      // context.getTopic()
      // const originalMessage = context.getMessage();
      // const partition = context.getPartition();
      // const { headers, timestamp } = originalMessage;

      // ä¸‹é¢çš„è¿”å› å¯ä»¥æ»¡è¶³ â€œå…±åŒåˆ†åŒºè¦æ±‚â€ key value
      return {
        headers: {
          realm: 'Nest',
        },
        key: message.value,
        value: dragons,
      };
    }
  }

  ï½ KafkaController
  import * as util from 'util';

  interface Dragon {
    id: number;
    name: string;
  }

  @Injectable()
  export class KafkaService implements OnModuleInit {
    private readonly logger = new Logger(KafkaService.name);

    // Dragon IDs from 1 to 3 are available
    private readonly minDragons = 1;
    private readonly maxDragons = 3;

    constructor(@Inject('M1_SERVICE') private readonly client: ClientKafka) {}

    async onModuleInit() {
      this.client.subscribeToResponseOf('hero.kill.dragon');

      // await this.client.connect();
    }

    private chooseDragonId(): number {
      return Math.floor(
        Math.random() * (this.maxDragons - this.minDragons + 1) + this.minDragons,
      );
    }

    // ç®€å•çš„ä½¿ç”¨
    // async killDragon() {
    //   this.logger.log('Killing the dragon...');
    //   this.logger.log('Success! Sending message to Kafka...');

    //   const dragon: Pick<Dragon, 'id'> = { id: this.chooseDragonId() };
    //   const killedDragon = await lastValueFrom(
    //     this.client.send<Dragon>('hero.kill.dragon', dragon),
    //   );

    //   this.logger.log(`Consumer response: ${util.inspect(killedDragon)}`);

    //   return `${killedDragon} is dead! The kingdom is saved!`;
    // }

    // æµ‹è¯• æ»¡è¶³åŒæ—¶åˆ†åŒº
    async killDragon() {
      const value = {
        id: 0,
        name: 'doc',
        heroId: 1,
        dragonId: 3,
      };

      const dragon: Pick<Dragon, 'id'> = value;
      const killedDragon = await lastValueFrom(
        this.client.send<Dragon>('hero.kill.dragon', dragon),
      );

      this.logger.log(`Consumer response: ${util.inspect(killedDragon)}`);

      return `${killedDragon} is dead! The kingdom is saved!`;
    }
  }

```

### gRPC
>
> å…³äºgRPC æˆ‘ç›¸ä¿¡å­¦ä¹ /æ¥è§¦è¿‡ Goçš„åŒå­¦ é¢‡æœ‰æ„Ÿè§¦å“ˆï¼Œ
> ç®€è€Œè¨€ä¹‹ gRPC æ˜¯ä¸€ä¸ªç°ä»£ã€å¼€æºã€é«˜æ€§èƒ½çš„ RPC æ¡†æ¶ï¼Œå¯ä»¥åœ¨ä»»ä½•ç¯å¢ƒä¸­è¿è¡Œã€‚æ³¨æ„å®ƒä¸Šä¸€ä¸ª RPC( è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ )

> å¦‚æœä½ æƒ³äº†è§£æ›´å¤š ï¼Œè¯·çœ‹æˆ‘çš„å¦ä¸€ç‰‡golang æ–‡ç«  <a href="https://github.com/BM-laoli/go-gin-example/tree/grpc">link</a>

1. å®‰è£… ä¾èµ–

```shell
pnpm add @grpc/grpc-js @grpc/proto-loader -w
```

2. æˆ‘ä»¬è¦ä½¿ç”¨åˆ° .proto æ–‡ä»¶ æ‰€ä»¥è¦è®¾ç½® tsçš„ç¼–è¯‘é¡¹

```ts
// nest-cli.json
"compilerOptions": {
    "assets": ["**/*.proto"]
  }

// tsconfig.json
"assets": ["**/*.proto"],
"watchAssets": true
```

3. å¼•å…¥å’Œå¯åŠ¨ ç¨‹åº

```ts
~ Service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.GRPC,
      options: {
        package: 'hero', // ['hero', 'hero2']
        protoPath: join(__dirname, './hero/hero.proto'), // ['./hero/hero.proto', './hero/hero2.proto']
      },
    },
  );
  await app.listen();

~ Client
  imports: [
    ClientsModule.register([
      {
        name: 'HERO_PACKAGE',
        transport: Transport.GRPC,
        options: {
          package: 'hero', // ['hero', 'hero2']
          protoPath: join(__dirname, './hero/hero.proto'), // ['./hero/hero.proto', './hero/hero2.proto']
        },
      },
    ]),
  ],
```

4. éƒ¨åˆ†ç®€å•çš„ä»£ç 

```ts
~ Service

export interface Hero {
  id: number;
  name: string;
}

export interface HeroById {
  id: number;
}

interface HeroService {
  findOne(data: HeroById): Observable<Hero>;
  findMany(upstream: Observable<HeroById>): Observable<Hero>;
}

@Controller()
export class GRPCController {
  private readonly items: Hero[] = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Doe' },
  ];

  // ç®€å•çš„ä¾‹å­
  // å¯¹åº”çš„å°±æ˜¯ HeroService é‡Œçš„FindOne æ–¹æ³•
  // è¿™ä¸¤ä¸ªå‚æ•° éƒ½æ˜¯å¯é€‰é¡¹ å¦‚æœ findOne å’ŒFindOne ä¸€æ · ï¼ˆfindOne
  // ä¼šè‡ªåŠ¨è½¬å¤§é©¼å³° ï¼Œé‚£ä¹ˆå¯ä»¥å¿½ç•¥ FindOne å‚æ•°
  // å¦‚æœ HeroService å’Œ Class HeroService ä¸€ä¸€è‡´ é‚£ä¹ˆè¿™ä¸ª HeroService
  // å‚æ•°ä¹Ÿå¯ä»¥çœå»ï¼Œä½†æ˜¯ä¸å»ºè®®

  @GrpcMethod('HeroService', 'FindOne')
  findOne(
    data: HeroById,
    metadata: Metadata,
    call: ServerUnaryCall<any, any>,
  ): Hero {
    return this.items.find(({ id }) => id === data.id);
  }

  // æˆ‘ä»¬èƒ½ä¸èƒ½å®ç° æµ ?
  // gRPC æœ¬èº«æ”¯æŒé•¿æœŸå®æ—¶è¿æ¥ï¼Œé€šå¸¸ç§°ä¸º .æµå¯¹äºèŠå¤©ã€è§‚å¯Ÿæˆ–å—æ•°æ®ä¼ è¾“ç­‰æƒ…å†µå¾ˆæœ‰ç”¨
  // Nest æœ‰ä¸¤ç§ æ–¹å¼å®ç°

  // RxJS + handler
  @GrpcStreamMethod('HeroService')
  findMany(data$: Observable<HeroById>): Observable<Hero> {
    const hero$ = new Subject<Hero>();

    const onNext = (heroById: HeroById) => {
      const item = this.items.find(({ id }) => id === heroById.id);
      hero$.next(item);
    };
    const onComplete = () => hero$.complete();
    data$.subscribe({
      next: onNext,
      complete: onComplete,
    });

    return hero$.asObservable();
  }
}


~ Client

export interface Hero {
  id: number;
  name: string;
}

export interface HeroById {
  id: number;
}

interface HeroService {
  findOne(data: HeroById): Observable<Hero>;
  findMany(upstream: Observable<HeroById>): Observable<Hero>;
}

@Controller('hero')
export class GRPCController implements OnModuleInit {
  private readonly items: Hero[] = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Doe' },
  ];
  private heroService: HeroService;
  constructor(@Inject('HERO_PACKAGE') private readonly client: ClientGrpc) {}

  onModuleInit() {
    this.heroService = this.client.getService<HeroService>('HeroService');
  }

  @Get()
  getHero(): Observable<any> {
    // å¯¹åº”çš„å°±æ˜¯ HeroesService é‡Œçš„FindOne æ–¹æ³•
    // æ³¨æ„ gRPC å®¢æˆ·ç«¯ä¸ä¼šå‘é€åç§°ä¸­åŒ…å«ä¸‹åˆ’çº¿çš„å­—æ®µ ï¼ˆè¦å‘è¯·è®¾ç½®
    //options.loader.keepcase = true
    return this.heroService.findOne({ id: 1 });
  }

  @Get('stream')
  getMany() {
    const ids$ = new ReplaySubject<HeroById>();
    ids$.next({ id: 1 });
    ids$.next({ id: 2 });
    ids$.complete();

    const stream = this.heroService.findMany(ids$.asObservable());
    return stream.pipe(toArray());
  }
}

```

## å…³äºå…¶å®ƒçš„æ“ä½œ

### è‡ªå®šä¹‰ä¼ è¾“å™¨

### æœ‰å…³Errorçš„æ“ä½œ

### Pip

### Guard

### Interceptors

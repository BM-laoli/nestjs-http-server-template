# 微服务

## 基础介绍（多个NestJS 程序之间的调用

> 介绍一下 多个Nest程序之间的调用方式 和实现
> 为了演示 功能，我们需要调整一下 程序，把它变成一个 monorepo 工程
> 具体到底如何 基于other_tech 我们新 拉一个分支 命名为 monorepo , 具体的集成方法 请参考为的 另一个 github参考 哪里有文章和例子 <https://github.com/BM-laoli/morerepo-test> (有可能learn 这种方式已经过时，请参考 )<https://juejin.cn/post/6964328103447363614#comment> 来做pnpm下的 monorepo
>

## Pnpm下的monorepo工程改造
>
> 参考文章 <https://juejin.cn/post/6964328103447363614#comment>
>
> 注意 以下内容 ，请不要直接拿去用，我仅仅做了演示为了图方便，在nest中如果你要实施 monorepo  请看 nest官方文档，官方文档提供了 一个适用 与Nest的方案 <https://docs.nestjs.com/cli/monorepo>. 当然你如果 想一意孤行 ，那么 哈哈哈 请参考下面的文档

1. 新建文件夹 (子项目)

packages/m1 这个文件夹下📁 下就有一个新的Nestjs 项目了

```shell
├── src
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── package.json
├── nest-cli.json
├── tsconfig.build.json
├── tsconfig.json
└── yarn.lock

```

注意改一下去掉 private，如果你需要 请改一下包名（大部分情况下 你并不需要去改 因为我们是两个 独立的 service, 除非你要做 lib，若做lib Nest官方也有详细说明

```json
{
  "name": "nest-m1",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  // 去掉 "private": true,
}
```

2. pnpm 初始化

```shell
# 初始化
$ pnpm init -y
```

新建一个 pnpm-workspace.yaml

```yaml
packages:
  # all packages in subdirs of packages/ and components/
  - 'packages/**'

```

3. 依赖安装

```shell
# root 目录(我们原来从 另一个branch 过来的 一样install就好了，既得install 前 把 node_mmodules 先干掉 )
$ pnpm install -w  # (意思是全局依赖)

# package/m1 目录
$ pnpm install 
```

然后 按照相同 的逻辑 我们再去 cv 文件，新建一个 client 文件夹 这样就算搞定了！

### Install

不管是 service / client 都需要使用这个依赖，注意这里说的 service 和client 是 指 微服务 和 请求他的其他服务（相对的 service | client

```shell
# $  npm i --save @nestjs/microservices
$ pnpm add @nestjs/microservices -w
```

### Service 端

在 main 引入

```ts
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      // 默认情况Nest 使用TCP，
      // options: {
      // host
      // port
      // retryAttempts 重试消息次数 默认 =0
      // retryDelay 邮件重试之间的间隔(ms)
      // },
    },
  );
```

再controller  中写些逻辑

需要特别强调的是 在Nest中 微服务通过**模式**识别消息和事件

- 请求-响应
- 基于事件

```ts
import {
  Controller,
  Get,
  Inject,
  RequestTimeoutException,
  Scope,
} from '@nestjs/common';
import {
  CONTEXT,
  Ctx,
  EventPattern,
  MessagePattern,
  NatsContext,
  Payload,
  RequestContext,
} from '@nestjs/microservices';
import { from, fromEvent, Observable } from 'rxjs';
import { AppService } from './app.service';

@Controller({
  scope: Scope.REQUEST,
})
export class AppController {
  constructor(
    private readonly appService: AppService,
    @Inject(CONTEXT) private ctx: RequestContext, // scope 的时候
  ) {}

  // 在Nest中有两种 微服务的模式来识别消息和事件

  // 下面就是 一个 (请求-响应)
  // 注意哈 这个decorator 只在 controller 中用
  @MessagePattern({ cmd: 'sum' })
  accumulate(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  // 异步/Observable  也是支持的
  @MessagePattern({ cmd: 'sumSync' })
  accumulateSync(data: number[]): Promise<number> {
    return Promise.resolve((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'sumObservable' })
  accumulateObservable(data: number[]): Observable<number> {
    return from([1, 2, 3, 4]);
  }

  // 以上是基于 请求+响应 的 下面咱们 来观察一下 基于 事件的
  @EventPattern('user_created')
  async cuser(data: any) {
    console.log(this.ctx.pattern);
    return 1;
  }
  // 我们可以为一个 事件注册多个处理程序 他们会依次触发
  @EventPattern('user_created')
  async cuser2(data: any) {
    return 2;
  }
  // 如果你需要一些 请求的详细信息 可以传递一个context
  @MessagePattern('time.use.*') // 通配符
  getDate(@Payload() data: number[], @Ctx() context: NatsContext) {
    return new Date().toLocaleDateString();
  }
}

```

### Client 端

关于client 的集成相对简单

注入+使用就好了

```ts
@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.TCP,
      },
    ]),
  ],
  controllers: [AppController, AppController2],
  providers: [AppService],
})
```

使用

```ts

@Controller('m1')
export class AppController {
  constructor(
    private readonly appService: AppService,
    @Inject('M1_SERVICE') private M1_client: ClientProxy,
  ) {}

  @Get()
  // t1(@Res() res: Response) {
  t1() {
    // this.M1_client.
    // return this.accumulate();
    // this.accumulate().subscribe((it) => {
    //   res.status(HttpStatus.OK).send(`${it}--`);
    // });
    // return this.accumulateSync();
    // return this.accumulateObservable();
    // return this.publish();
    return this.publish2();
  }

  // 请求响应模式
  accumulate() {
    const pattern = { cmd: 'sum' };
    const payload = [1, 2, 3];
    // 注意这个默认都是返回一个 "冷Observable"
    return this.M1_client.send<number[]>(pattern, payload);
  }

  async accumulateSync() {
    const pattern = { cmd: 'sumSync' };
    const payload = [1, 2, 3, 4];

    const value = await lastValueFrom(
      this.M1_client.send<number[]>(pattern, payload),
    );

    return value;
  }

  accumulateObservable() {
    const pattern = { cmd: 'sumObservable' };
    const payload = [1, 2, 3, 4, 5];

    // 模拟操作 可以使用 pipe(timeout(5000)) 这个操作符
    return this.M1_client.send<number[]>(pattern, payload);
  }

  // 发送事件 注意啊这个返回的是 一个热的Observable
  async publish() {
    this.M1_client.emit<number>('user_created', 666);
  }

  async publish2() {
    this.M1_client.emit<number>('time.use.*', 2123);
  }
}
```

你也许需要注意的一个点是Scope 的情况

在 Nest 中，几乎所有内容都在传入请求之间共享，
这可能是意想不到的。我们有一个数据库的连接池，具有全局状态的单例服务等。
请记住，Node.js 不遵循请求/响应多线程无状态模型，其中每个请求都由单独的线程处理。
因此，使用单一实例对于我们的应用程序是完全安全的。 但多数情况下 我们会有一些缓存策略 导致程序表现出意想不到的行为 故我们把模式改了

```ts

@Controller({
  path: 'm2',
  scope: Scope.REQUEST,
})
export class AppController2 {
  constructor(
    @Inject('M1_SERVICE') private M1_client: ClientProxy,
    @Inject(CONTEXT) private ctx: RequestContext, // scope 的时候
  ) {}

  @Get()
  t1() {
    // this.M1_client.
  }
  // 请求响应模式
  accumulate() {
    const pattern = { cmd: 'sum' };
    const payload = [1, 2, 3];
    // 注意这个默认都是返回一个 "冷Observable"
    this.ctx.pattern;
    return this.M1_client.send<number[]>(pattern, payload);
  }
}
```

## 集成其它的工具🔧
>
> 接下里的内容 主要增强 上述的 微服务能力，因为可以看出来，上述的设计比较简单，没有考虑到 多机器 多名称的情况，而且我们 也没有配置 port 如果是 k8s 等多机器部署，那么服务发现该如何处理..... 都没有讲到, 下面的工具 旨在完善 ，微服务间存在的问题

### Redis
>
> Transport.REDIS并利用了 Redis 的发布/订阅功能， 设置了一套**发布/订阅**的消息传递范例，

当然特性(有点与不足) 要讲一下

1. 无法明确最终那个订阅者会收到消息(无法保证消息或事件将由至少一个服务处理)
2. 每个微服务可以订阅任意数量的通道，一次性可订阅多个通道
3. 通过通道交换的消息是 **即发即弃**， 如果没有人用 那会被删除掉
4. 一条消息 可以被多个 订阅者订阅和接收

<img src="https://docs.nestjs.com/assets/Redis_1.png" />

基础的用法和前文提到的 是一模一样的，不过要注意 不同的类型(我是指 ts 定义的类型 他们提供的功能不一样)

```ts
～ 详细见 MicroserviceOptions .d.ts 定义
/**
 * @publicApi
 */
export interface RedisOptions {
    transport?: Transport.REDIS;
    options?: {
        host?: string;
        port?: number;
        retryAttempts?: number;
        retryDelay?: number;
        serializer?: Serializer;
        deserializer?: Deserializer;
    } & IORedisOptions;
}
```

为了演示多个 microservices 之间的同时订阅，我们把 M1(在上节中它作为一个microservices ) , 再cv一份 重命名为 m2文件夹， 然后run

安装必要的依赖

```shell
npm i --save ioredis
pnpm add ioredis -w
```

修改 service 并且加一个 订阅器

```ts
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.REDIS,
      options: {
        host: 'localhost',
        port: 6379,
      },
    },
  );

++++
  // redis
  @MessagePattern('notifications')
  getNotifications(@Payload() data: number[], @Ctx() context: RedisContext) {
    console.log(`Channel: ${context.getChannel()}`); // notifications
    console.log(222);
  }
```

修改 client 换一个 事件发布

```ts
  ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.REDIS,
        options: {
          host: 'localhost',
          port: 6379,
        },
      },
    ]),
  ++++
  // redis
  async publishToRedis() {
    this.M1_client.emit<number>('notifications', 2123);
  }
```

最后说一下它的应用场景

在微服务架构中 Redis通常用作消息队列，适合处理高并发的消息传递；
但是Redis不是专门设计用来处理消息传递的，在需要保证消息顺序的前提下 redis 也许不是最好的选择。 下面的几种场景可以使用

|应用场景|des|
|----|----|
|异步任务处理| 将需要异步执行的任务放入Redis消息队列中，处理任务的工作进程从队列中读取任务，完成后将结果写回Redis或其他存储系统中。这种方式可以避免任务处理过程中阻塞主线程，提高系统的并发处理能力。 |
| 实时消息推送 | 通过Redis消息队列将实时消息推送给客户端，例如在线聊天、股票行情等。消息发布者将消息写入Redis消息队列中，订阅者通过订阅Redis消息频道或使用Redis的PUBLISH命令来接收消息。 |
|异步任务处理 | 将应用产生的日志信息写入Redis消息队列中，使用工作进程从队列中读取日志并进行处理，例如过滤、分析、存储等。这种方式可以避免日志处理过程中阻塞主线程，提高系统的性能和可靠性。 |

### MQTT
>
> MQTT（消息队列遥测传输）是一种开源的轻量级消息传递协 .
> 基于 MQTT 构建的通信系统由 发布服务器、代理和一个或多个客户端组成。它专为受限设备和低带宽、高延迟或不可靠的网络而设计。

总体来说 它成本低 而且效果好 延迟低，非常适合用在 物联网, 传感器 和服务器的通信

首先我们需要构建这样的一套基础设施 ，我们使用docker 去构建
，再次强调**因为MQTT是一个协议，所以我们需要搭建一个支持MQTT协议的服务器，使服务端和客户端能够通过这个MQTT服务器（broker）进行消息转发、通信**

EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器，它是目前比较好 MQTT 服务产品，多了不说了 自己去search吧

```shell
$ docker pull emqx
$ docker run -d --name emqx -p 1883:1883 -p 18083:18083 emqx/emqx

# 完事之后 管理端 在 :18083  admin/public 中登录管理 

# 在工程 root 目录下安装 mqtt 依赖
$  pnpm add mqtt -w
```

接下来 开始集成, 把service 和 client的协议改了

```ts
～ service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.MQTT,
      options: {
        url: 'mqtt://localhost:1883',
      },
    },
  );

～ client
    ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.MQTT,
        options: {
          url: 'mqtt://localhost:1883',
         
        },
      },
    ]),
```

然后我们 多加一些发布和订阅的代码( 实际上和 之前的那些类型，代码都是一样的版式 )

```ts
～ service
  // MQTT
  // @MessagePattern('sensors/+/temperature/+') 支持通配符
  @MessagePattern('notificationsMQTT')
  getNotificationsMQTT(@Payload() data: number[], @Ctx() context: MqttContext) {
    console.log(`Topic: ${context.getTopic()}`); // notifications
    console.log(222);

    // 如果你需要访问 原始的mqtt数据包 请使用
    console.log(context.getPacket());
  }

  // MQTT2
  @MessagePattern('replace-emoji')
  replaceEmoji(@Payload() data: string, @Ctx() context: MqttContext): string {
    const {
      properties: { userProperties },
      // 如果你这里 是一个undefined 记得去给你的 配置 加一个 协议版本  protocolVersion: 5,
      // issues  https://github.com/nestjs/nest/issues/10016
    } = context.getPacket();

    console.log('2');

    return userProperties['x-version'] === '1.0.0' ? '🐱' : '🐈';
  }

～ Client
// MQTT
  publishToMQTT() {
    // this.M1_client.emit<number>('notificationsMQTT', {
    //   name: 6666,
    // });

    // 配置 消息选项
    const userProperties = { 'x-version': '1.0.0' };
    const record = new MqttRecordBuilder(':cat:')
      .setProperties({ userProperties })
      .setQoS(1)
      .build();
    console.log(record);

    return this.M1_client.send('replace-emoji', record);
  }

```

### NATS
>
> 这个东西 也是一个消息传递系统,目前最新版本 使用Go开发 性能非常的NB，它是一个分布式的消息中间件

同样的代理 它也是有直接的消息协议，请先安装 这个系统

```shell
$ docker pull nats
$ docker run -d --name nats-main -p 4222:4222 -p 8222:8222 nats

# 安装ndoejs 依赖
$ pnpm add nats -w
```

特别要说明的: Nest Transport.NATS 不使用 NATS 内置的 请求-响应 传输机制，无论响应的Service在什么地方，它都会动态的返回 到 client程序.

但对于 基于事件 的传输模式，Nest 使用NATS 内置的机制，如果发布一个基于主题的message时，订阅这个主题的 都会收到此消息( 这种一对多 被称为 扇出)

然后 NATS 提供了一个内置的 分布式队列 ，如果要使用情况 下面的代码

```ts
~ Service
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.NATS,
      options: {
        servers: ['nats://localhost:4222'],
      },
    },
  );

~ Client
  ClientsModule.register([
      {
        name: 'M1_SERVICE',
        transport: Transport.NATS,
        options: {
          servers: ['nats://localhost:4222'],
        },
      },
    ]),
```

然后就是多加几个 订阅 和publish 方法

```ts
~ Service
  // NTAS
  @MessagePattern('notificationsNATS')
  notificationsNATS(@Payload() data: number[], @Ctx() context: NatsContext) {
    console.log(`Subject: ${context.getSubject()}`);
  }

  // NATS 可以设置 标头
  @MessagePattern('replace-emoji-NATS')
  replaceEmojiNATS(
    @Payload() data: string,
    @Ctx() context: NatsContext,
  ): string {
    const headers = context.getHeaders();
    // 这个返回时一个是get 不要相信官方给写的 headers['x-version']
    return headers.get('x-version') === '1.0.0' ? '🐱' : '🐈';
  }

~  Client
import * as nats from 'nats';

  // NAST
  publishToNAST() {
    // this.M1_client.emit<number>('notificationsNATS', {
    //   name: 6666,
    // });

    // 配置 消息选项
    const headers = nats.headers();
    headers.set('x-version', '1.0.0');
    const record = new NatsRecordBuilder(':cat:').setHeaders(headers).build();

    this.M1_client.send('replace-emoji-NATS', record).subscribe((it) => {
      console.log(it);
    });
  }
```

### RabbitMQ

### Kafka

### gRPC

## 关于其它的操作

### 自定义传输器

### 有关Error的操作

### Pip

### Guard

### Interceptors
